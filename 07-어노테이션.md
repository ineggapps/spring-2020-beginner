# 어노테이션

- 어노테이션을 읽어서 해석하고 그에 맞게 처리해 주는 클래스가 필요하다.
- 따라서 applicationContext.xml에 다음의 값을 지정해 주어야 한다.
- context: [xmlns:context="http://www.springframework.org/schema/context"](http://www.springframework.org/schema/context)
- 다만 다음의 선언을 꼭 해야 한다.

```xml
<context:annotation-config />
```

- 다만 @Required, @Autowired, @Resource, @PostConstruct, @PreDestroy, @Configuration만 해석할 수 있다.

## @Required

- setter 앞에 @required를 선언하면 필수 항목으로 지정할 수 있다.
- required를 지정한 항목에 아무 값도 기입하지 않은 경우에는 다음과 같은 오류가 발생한다
  > > Caused by: org.springframework.beans.factory.BeanInitializationException: Property 'name' is required for bean 'userService'

## @Autowired

- 자주 사용되는 어노테이션 (타입 기반)
- 필드 선언부 위에 선언. 의존 관계를 타입으로 자동으로 설정하므로 setter 메서드가 필요하지 않다.
- 단, 동일한 타입의 객체가 2개 이상 xml에 선언되면 필드명과 동일한 id를 먼저 찾는다. 없으면 에외가 발생된다.
  - No qualifying bean of type 'com.test3.UserService' available: expected single matching bean but found 2: userService1,userService2
- 선언하지 않으면 Exception in thread "main" java.lang.NullPointerException 예외 발생

```java
//의존관계를 타입으로 자동 설정. setter가 필요하지 않다.
@Autowired
private UserService userService;// 인터페이스에 의존관계를 가지고 있는 UserBean
```

## @Qualifier("xml에서 선언한 객체id")

- 반드시 @Autowired와 같이 사용하며, 동일한 타입이 두 개 이상인 경우 id로 의존관계를 설정한다.
- 동일한 타입의 객체가 2개 이상 Autowired되면 예외가 발생하는데, 이럴 때 특정 id를 지정해주는 경우에는 예외가 발생하지 않는다.

## @Inject

- JAVA에서 지원하는 어노테이션 (타입 기반)
- MVN repository에서 [다운로드](https://mvnrepository.com/artifact/javax.inject/javax.inject/1)해서 pom.xml에 등록한 후 사용할 수 있다.

```java
import javax.inject.Inject;
```

## @Resource(name=id명)

- id를 이용하여 의존관계를 설정한다. (java의 어노테이션이다.)

```java
import javax.annotation.Resource;
```

## @PostConstruct, @PreDestroy

### @PostConstruct: 생성자 다음 호출되는 초기화 메서드

- xml의 init-method 속성을 다음의 어노테이션으로 지정할 수 있다.

### @PreDestroy: 소멸 직전에 호출되는 메서드

- xml의 destroy-method 속성을 다음의 어노테이션으로 지정할 수 있다.

## @Configuration

===

## @Component

- bean태그를 사용하지 않아도 객체를 자동으로 생성해 준다.
- 단, 다음의 xml을 등록해 주어야 한다.

```xml
<!--해당 폴더의 클래스를 스캔-->
<context:component-scan base-package="패키지명"/>
```

- wildcard를 지정할 수 있다.
- 단 같은 클래스가 이하 도메인에서 겹치는 경우에는 예외가 발생할 것이다.
  - ex: non-compatible bean definition of same name and class [com.test7.UserBean]

```xml
<!-- 모든 클래스 스캔-->
<context:component-scan base-package="*"/>
```

```xml
<!-- 해당 폴더의 모든 클래스 스캔-->
<context:component-scan base-package="com.test.*"/>
```

- 위의 xml구문은 다음의 어노테이션을 해석하고 실행한다.

  - @Component 어노테이션은 id는 자동으로 첫글자가 소문자인 클래스명이 부여된다.
  - @Component, @Service, @Conroller, @Repository: 객체 생성에 관한 어노테이션
    - @Service, @Controller, @Repository는 @Component의 자손이다.
      - @Service: 로직을 담당 (페이징처리, 파일 처리 등)
      - @Controller: MVC패턴에서 사용하는 컨트롤러에만 붙일 수 있는 어노테이션
      - @Repository: DAO클래스 (DB작업), 예외처리를 이용하기 위해 사용하는 어노테이션이다.
  - @Autowired, @Resource 등...

- 그런데, @Component어노테이션이 임의로 id값을 지정해 줄 수 도 있다.
  - @Component("패키지명.아이디")

## @Scope

- 참고: 자주 사용되지는 않음.
- @Component로 객체를 생성할 때 Scope 옵션을 지정할 수 있다.
- @Scope(value="prototype")
- 메서드를 호출할 때마다 객체가 생성되도록 옵션을 지정하고 싶으면 다음의 어노테이션을 지정한다

```java
@Scope(value="prototype", proxyMode=ScopedProxyMode.TARGET_CLASS)
```

위의 자바 코드는 xml에서 다음의 속성과 동일한 효과를 낸다.

```xml
<aop:scoped-proxy>
```
